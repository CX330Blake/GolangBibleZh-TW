# 前言

## Go語言起源

編程語言的演化跟生物物種的演化類似，一個成功的編程語言的後代一般都會繼承它們祖先的優點；當然有時多種語言雜合也可能會產生令人驚訝的特性；還有一些激進的新特性可能並沒有先例。通過觀察這些影響，我們可以學到爲什麼一門語言是這樣子的，它已經適應了怎樣的環境。

下圖展示了有哪些早期的編程語言對Go語言的設計產生了重要影響。

![](./images/ch0-01.png)

Go語言有時候被描述爲“類C語言”，或者是“21世紀的C語言”。Go從C語言繼承了相似的表達式語法、控制流結構、基礎數據類型、調用參數傳值、指針等很多思想，還有C語言一直所看中的編譯後機器碼的運行效率以及和現有操作系統的無縫適配。

但是在Go語言的家族樹中還有其它的祖先。其中一個有影響力的分支來自[Niklaus Wirth](https://en.wikipedia.org/wiki/Niklaus_Wirth)所設計的`Pascal`語言。然後`Modula-2`語言激發了包的概念。然後`Oberon`語言摒棄了模塊接口文件和模塊實現文件之間的區別。第二代的`Oberon-2`語言直接影響了包的導入和聲明的語法，還有`Oberon`語言的面向對象特性所提供的方法的聲明語法等。

Go語言的另一支祖先，帶來了Go語言區別其他語言的重要特性，靈感來自於貝爾實驗室的[Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)於1978年發表的鮮爲外界所知的關於併發研究的基礎文獻 *順序通信進程* （ *communicating sequential processes* ，縮寫爲`CSP`。在`CSP`中，程序是一組中間沒有共享狀態的平行運行的處理過程，它們之間使用管道進行通信和控制同步。不過[Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)的`CSP`只是一個用於描述併發性基本概念的描述語言，並不是一個可以編寫可執行程序的通用編程語言。

接下來，Rob Pike和其他人開始不斷嘗試將[CSP](https://en.wikipedia.org/wiki/Communicating_sequential_processes)引入實際的編程語言中。他們第一次嘗試引入[CSP](https://en.wikipedia.org/wiki/Communicating_sequential_processes)特性的編程語言叫[Squeak](http://doc.cat-v.org/bell_labs/squeak/)（老鼠間交流的語言），是一個提供鼠標和鍵盤事件處理的編程語言，它的管道是靜態創建的。然後是改進版的[Newsqueak](http://doc.cat-v.org/bell_labs/squeak/)語言，提供了類似`C`語言語句和表達式的語法和類似`Pascal`語言的推導語法。`Newsqueak`是一個帶垃圾回收的純函數式語言，它再次針對鍵盤、鼠標和窗口事件管理。但是在`Newsqueak`語言中管道是動態創建的，屬於第一類值，可以保存到變量中。

在`Plan9`操作系統中，這些優秀的想法被吸收到了一個叫`Alef`的編程語言中。`Alef`試圖將`Newsqueak`語言改造爲系統編程語言，但是因爲缺少垃圾回收機制而導致併發編程很痛苦。（譯註：在`Alef`之後還有一個叫`Limbo`的編程語言，Go語言從其中借鑑了很多特性。 具體請參考Pike的講稿：http://talks.golang.org/2012/concurrency.slide#9 ）

Go語言的其他的一些特性零散地來自於其他一些編程語言；比如`iota`語法是從`APL`語言借鑑，詞法作用域與嵌套函數來自於`Scheme`語言（和其他很多語言）。當然，我們也可以從Go中發現很多創新的設計。比如Go語言的切片爲動態數組提供了有效的隨機存取的性能，這可能會讓人聯想到鏈表的底層的共享機制。還有Go語言新發明的`defer`語句。

## Go語言項目

所有的編程語言都反映了語言設計者對編程哲學的反思，通常包括之前的語言所暴露的一些不足地方的改進。Go項目是在Google公司維護超級複雜的幾個軟件系統遇到的一些問題的反思（但是這類問題絕不是Google公司所特有的）。

正如[Rob Pike](http://genius.cat-v.org/rob-pike/)所說，“軟件的複雜性是乘法級相關的”，通過增加一個部分的複雜性來修復問題通常將慢慢地增加其他部分的複雜性。通過增加功能、選項和配置是修復問題的最快的途徑，但是這很容易讓人忘記簡潔的內涵，即從長遠來看，簡潔依然是好軟件的關鍵因素。

簡潔的設計需要在工作開始的時候捨棄不必要的想法，並且在軟件的生命週期內嚴格區別好的改變和壞的改變。通過足夠的努力，一個好的改變可以在不破壞原有完整概念的前提下保持自適應，正如[Fred Brooks](http://www.cs.unc.edu/~brooks/)所說的“概念完整性”；而一個壞的改變則不能達到這個效果，它們僅僅是通過膚淺的和簡單的妥協來破壞原有設計的一致性。只有通過簡潔的設計，才能讓一個系統保持穩定、安全和持續的進化。

Go項目包括編程語言本身，附帶了相關的工具和標準庫，最後但並非代表不重要的是，關於簡潔編程哲學的宣言。就事後諸葛的角度來看，Go語言的這些地方都做的還不錯：擁有自動垃圾回收、一個包系統、函數作爲一等公民、詞法作用域、系統調用接口、只讀的UTF8字符串等。但是Go語言本身只有很少的特性，也不太可能添加太多的特性。例如，它沒有隱式的數值轉換，沒有構造函數和析構函數，沒有運算符重載，沒有默認參數，也沒有繼承，沒有泛型，沒有異常，沒有宏，沒有函數修飾，更沒有線程局部存儲。但是，語言本身是成熟和穩定的，而且承諾保證向後兼容：用之前的Go語言編寫程序可以用新版本的Go語言編譯器和標準庫直接構建而不需要修改代碼。

Go語言有足夠的類型系統以避免動態語言中那些粗心的類型錯誤，但是，Go語言的類型系統相比傳統的強類型語言又要簡潔很多。雖然，有時候這會導致一個“無類型”的抽象類型概念，但是Go語言程序員並不需要像`C++`或`Haskell`程序員那樣糾結於具體類型的安全屬性。在實踐中，Go語言簡潔的類型系統給程序員帶來了更多的安全性和更好的運行時性能。

Go語言鼓勵當代計算機系統設計的原則，特別是局部的重要性。它的內置數據類型和大多數的準庫數據結構都經過精心設計而避免顯式的初始化或隱式的構造函數，因爲很少的內存分配和內存初始化代碼被隱藏在庫代碼中了。Go語言的聚合類型（結構體和數組）可以直接操作它們的元素，只需要更少的存儲空間、更少的內存寫操作，而且指針操作比其他間接操作的語言也更有效率。由於現代計算機是一個並行的機器，Go語言提供了基於`CSP`的併發特性支持。Go語言的動態棧使得輕量級線程`goroutine`的初始棧可以很小，因此，創建一個`goroutine`的代價很小，創建百萬級的`goroutine`完全是可行的。

Go語言的標準庫（通常被稱爲語言自帶的電池），提供了清晰的構建模塊和公共接口，包含I/O操作、文本處理、圖像、密碼學、網絡和分佈式應用程序等，並支持許多標準化的文件格式和編解碼協議。庫和工具使用了大量的約定來減少額外的配置和解釋，從而最終簡化程序的邏輯，而且，每個Go程序結構都是如此的相似，因此，Go程序也很容易學習。使用Go語言自帶工具構建Go語言項目只需要使用文件名和標識符名稱，一個偶爾的特殊註釋來確定所有的庫、可執行文件、測試、基準測試、例子、以及特定於平臺的變量、項目的文檔等；Go語言源代碼本身就包含了構建規範。

## 本書的組織

我們假設你已經有一種或多種其他編程語言的使用經歷，不管是類似C、C++或Java的編譯型語言，還是類似Python、Ruby、JavaScript的腳本語言，因此我們不會像對完全的編程語言初學者那樣解釋所有的細節。因爲，Go語言的變量、常量、表達式、控制流和函數等基本語法也是類似的。

第一章包含了本教程的基本結構，通過十幾個程序介紹了用Go語言如何實現類似讀寫文件、文本格式化、創建圖像、網絡客戶端和服務器通訊等日常工作。

第二章描述了Go語言程序的基本元素結構、變量、新類型定義、包和文件、以及作用域等概念。第三章討論了數字、布爾值、字符串和常量，並演示瞭如何顯示和處理Unicode字符。第四章描述了複合類型，從簡單的數組、字典、切片到動態列表。第五章涵蓋了函數，並討論了錯誤處理、panic和recover，還有defer語句。

第一章到第五章是基礎部分，主流命令式編程語言這部分都類似。個別之處，Go語言有自己特色的語法和風格，但是大多數程序員能很快適應。其餘章節是Go語言特有的：方法、接口、併發、包、測試和反射等語言特性。

Go語言的面向對象機制與一般語言不同。它沒有類層次結構，甚至可以說沒有類；僅僅通過組合（而不是繼承）簡單的對象來構建複雜的對象。方法不僅可以定義在結構體上，而且，可以定義在任何用戶自定義的類型上；並且，具體類型和抽象類型（接口）之間的關係是隱式的，所以很多類型的設計者可能並不知道該類型到底實現了哪些接口。方法在第六章討論，接口在第七章討論。

第八章討論了基於順序通信進程（CSP）概念的併發編程，使用goroutines和channels處理併發編程。第九章則討論了傳統的基於共享變量的併發編程。

第十章描述了包機制和包的組織結構。這一章還展示瞭如何有效地利用Go自帶的工具，使用單個命令完成編譯、測試、基準測試、代碼格式化、文檔以及其他諸多任務。

第十一章討論了單元測試，Go語言的工具和標準庫中集成了輕量級的測試功能，避免了強大但複雜的測試框架。測試庫提供了一些基本構件，必要時可以用來構建複雜的測試構件。

第十二章討論了反射，一種程序在運行期間審視自己的能力。反射是一個強大的編程工具，不過要謹慎地使用；這一章利用反射機制實現一些重要的Go語言庫函數，展示了反射的強大用法。第十三章解釋了底層編程的細節，在必要時，可以使用unsafe包繞過Go語言安全的類型系統。

每一章都有一些練習題，你可以用來測試你對Go的理解，你也可以探討書中這些例子的擴展和替代。

書中所有的代碼都可以從 http://gopl.io 上的Git倉庫下載。go get命令根據每個例子的導入路徑智能地獲取、構建並安裝。只需要選擇一個目錄作爲工作空間，然後將GOPATH環境變量設置爲該路徑。

必要時，Go語言工具會創建目錄。例如：

```
$ export GOPATH=$HOME/gobook    # 選擇工作目錄
$ go get gopl.io/ch1/helloworld # 獲取/編譯/安裝
$ $GOPATH/bin/helloworld        # 運行程序
Hello, 世界                     # 這是中文
```

運行這些例子需要安裝Go1.5以上的版本。

```
$ go version
go version go1.5 linux/amd64
```

如果使用其他的操作系統，請參考 https://golang.org/doc/install 提供的說明安裝。


## 更多的信息

最佳的幫助信息來自Go語言的官方網站，https://golang.org ，它提供了完善的參考文檔，包括編程語言規範和標準庫等諸多權威的幫助信息。同時也包含了如何編寫更地道的Go程序的基本教程，還有各種各樣的在線文本資源和視頻資源，它們是本書最有價值的補充。Go語言的官方博客 https://blog.golang.org 會不定期發佈一些Go語言最好的實踐文章，包括當前語言的發展狀態、未來的計劃、會議報告和Go語言相關的各種會議的主題等信息（譯註： http://talks.golang.org/ 包含了官方收錄的各種報告的講稿）。

在線訪問的一個有價值的地方是可以從web頁面運行Go語言的程序（而紙質書則沒有這麼便利了）。這個功能由來自 https://play.golang.org 的 Go Playground 提供，並且可以方便地嵌入到其他頁面中，例如 https://golang.org 的主頁，或 godoc 提供的文檔頁面中。

Playground可以簡單的通過執行一個小程序來測試對語法、語義和對程序庫的理解，類似其他很多語言提供的REPL即時運行的工具。同時它可以生成對應的url，非常適合共享Go語言代碼片段，彙報bug或提供反饋意見等。

基於 Playground 構建的 Go Tour，https://tour.golang.org ，是一個系列的Go語言入門教程，它包含了諸多基本概念和結構相關的並可在線運行的互動小程序。

當然，Playground 和 Tour 也有一些限制，它們只能導入標準庫，而且因爲安全的原因對一些網絡庫做了限制。如果要在編譯和運行時需要訪問互聯網，對於一些更復雜的實驗，你可能需要在自己的電腦上構建並運行程序。幸運的是下載Go語言的過程很簡單，從 https://golang.org 下載安裝包應該不超過幾分鐘（譯註：感謝偉大的長城，讓大陸的Gopher們都學會了自己打洞的基本生活技能，下載時間可能會因爲洞的大小等因素從幾分鐘到幾天或更久），然後就可以在自己電腦上編寫和運行Go程序了。

Go語言是一個開源項目，你可以在 https://golang.org/pkg 閱讀標準庫中任意函數和類型的實現代碼，和下載安裝包的代碼完全一致。這樣，你可以知道很多函數是如何工作的， 通過挖掘找出一些答案的細節，或者僅僅是出於欣賞專業級Go代碼。

## 致謝

[Rob Pike](http://genius.cat-v.org/rob-pike/)和[Russ Cox](http://research.swtch.com/)，以及很多其他Go團隊的核心成員多次仔細閱讀了本書的手稿，他們對本書的組織結構和表述用詞等給出了很多寶貴的建議。在準備日文版翻譯的時候，Yoshiki Shibata更是仔細地審閱了本書的每個部分，及時發現了諸多英文和代碼的錯誤。我們非常感謝本書的每一位審閱者，並感謝對本書給出了重要的建議的Brian Goetz、Corey Kosak、Arnold Robbins、Josh Bleecher Snyder和Peter Weinberger等人。

我們還感謝Sameer Ajmani、Ittai Balaban、David Crawshaw、Billy Donohue、Jonathan Feinberg、Andrew Gerrand、Robert Griesemer、John Linderman、Minux Ma（譯註：中國人，Go團隊成員。）、Bryan Mills、Bala Natarajan、Cosmos Nicolaou、Paul Staniforth、Nigel Tao（譯註：好像是陶哲軒的兄弟）以及Howard Trickey給出的許多有價值的建議。我們還要感謝David Brailsford和Raph Levien關於類型設置的建議。

我們從來自Addison-Wesley的編輯Greg Doench收到了很多幫助，從最開始就得到了越來越多的幫助。來自AW生產團隊的John Fuller、Dayna Isley、Julie Nahil、Chuti Prasertsith到Barbara Wood，感謝你們的熱心幫助。

[Alan Donovan](https://github.com/adonovan)特別感謝：Sameer Ajmani、Chris Demetriou、Walt Drummond和Google公司的Reid Tatge允許他有充裕的時間去寫本書；感謝Stephen Donovan的建議和始終如一的鼓勵，以及他的妻子Leila Kazemi並沒有讓他爲了家庭瑣事而分心，並熱情堅定地支持這個項目。

[Brian Kernighan](http://www.cs.princeton.edu/~bwk/)特別感謝：朋友和同事對他的耐心和寬容，讓他慢慢地梳理本書的寫作思路。同時感謝他的妻子Meg和其他很多朋友對他寫作事業的支持。

2015年 10月 於 紐約

