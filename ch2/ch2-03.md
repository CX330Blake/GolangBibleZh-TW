## 2.3. 變量

var聲明語句可以創建一個特定類型的變量，然後給變量附加一個名字，並且設置變量的初始值。變量聲明的一般語法如下：

```Go
var 變量名字 類型 = 表達式
```

其中“*類型*”或“*= 表達式*”兩個部分可以省略其中的一個。如果省略的是類型信息，那麼將根據初始化表達式來推導變量的類型信息。如果初始化表達式被省略，那麼將用零值初始化該變量。 數值類型變量對應的零值是0，布爾類型變量對應的零值是false，字符串類型對應的零值是空字符串，接口或引用類型（包括slice、指針、map、chan和函數）變量對應的零值是nil。數組或結構體等聚合類型對應的零值是每個元素或字段都是對應該類型的零值。

零值初始化機制可以確保每個聲明的變量總是有一個良好定義的值，因此在Go語言中不存在未初始化的變量。這個特性可以簡化很多代碼，而且可以在沒有增加額外工作的前提下確保邊界條件下的合理行爲。例如：

```Go
var s string
fmt.Println(s) // ""
```

這段代碼將打印一個空字符串，而不是導致錯誤或產生不可預知的行爲。Go語言程序員應該讓一些聚合類型的零值也具有意義，這樣可以保證不管任何類型的變量總是有一個合理有效的零值狀態。

也可以在一個聲明語句中同時聲明一組變量，或用一組初始化表達式聲明並初始化一組變量。如果省略每個變量的類型，將可以聲明多個類型不同的變量（類型由初始化表達式推導）：

```Go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

初始化表達式可以是字面量或任意的表達式。在包級別聲明的變量會在main入口函數執行前完成初始化（§2.6.2），局部變量將在聲明語句被執行到的時候完成初始化。

一組變量也可以通過調用一個函數，由函數返回的多個返回值初始化：

```Go
var f, err = os.Open(name) // os.Open returns a file and an error
```

### 2.3.1. 簡短變量聲明

在函數內部，有一種稱爲簡短變量聲明語句的形式可用於聲明和初始化局部變量。它以“名字 := 表達式”形式聲明變量，變量的類型根據表達式來自動推導。下面是lissajous函數中的三個簡短變量聲明語句（§1.4）：

```Go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

因爲簡潔和靈活的特點，簡短變量聲明被廣泛用於大部分的局部變量的聲明和初始化。var形式的聲明語句往往是用於需要顯式指定變量類型的地方，或者因爲變量稍後會被重新賦值而初始值無關緊要的地方。

```Go
i := 100                  // an int
var boiling float64 = 100 // a float64
var names []string
var err error
var p Point
```

和var形式聲明語句一樣，簡短變量聲明語句也可以用來聲明和初始化一組變量：

```Go
i, j := 0, 1
```

但是這種同時聲明多個變量的方式應該限制只在可以提高代碼可讀性的地方使用，比如for語句的循環的初始化語句部分。

請記住“:=”是一個變量聲明語句，而“=”是一個變量賦值操作。也不要混淆多個變量的聲明和元組的多重賦值（§2.4.1），後者是將右邊各個表達式的值賦值給左邊對應位置的各個變量：

```Go
i, j = j, i // 交換 i 和 j 的值
```

和普通var形式的變量聲明語句一樣，簡短變量聲明語句也可以用函數的返回值來聲明和初始化變量，像下面的os.Open函數調用將返回兩個值：

```Go
f, err := os.Open(name)
if err != nil {
	return err
}
// ...use f...
f.Close()
```

這裏有一個比較微妙的地方：簡短變量聲明左邊的變量可能並不是全部都是剛剛聲明的。如果有一些已經在相同的詞法域聲明過了（§2.7），那麼簡短變量聲明語句對這些已經聲明過的變量就只有賦值行爲了。

在下面的代碼中，第一個語句聲明瞭in和err兩個變量。在第二個語句只聲明瞭out一個變量，然後對已經聲明的err進行了賦值操作。

```Go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

簡短變量聲明語句中必須至少要聲明一個新的變量，下面的代碼將不能編譯通過：

```Go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

解決的方法是第二個簡短變量聲明語句改用普通的多重賦值語句。

簡短變量聲明語句只有對已經在同級詞法域聲明過的變量才和賦值操作語句等價，如果變量是在外部詞法域聲明的，那麼簡短變量聲明語句將會在當前詞法域重新聲明一個新的變量。我們在本章後面將會看到類似的例子。

### 2.3.2. 指針

一個變量對應一個保存了變量對應類型值的內存空間。普通變量在聲明語句創建時被綁定到一個變量名，比如叫x的變量，但是還有很多變量始終以表達式方式引入，例如x[i]或x.f變量。所有這些表達式一般都是讀取一個變量的值，除非它們是出現在賦值語句的左邊，這種時候是給對應變量賦予一個新的值。

一個指針的值是另一個變量的地址。一個指針對應變量在內存中的存儲位置。並不是每一個值都會有一個內存地址，但是對於每一個變量必然有對應的內存地址。通過指針，我們可以直接讀或更新對應變量的值，而不需要知道該變量的名字（如果變量有名字的話）。

如果用“var x int”聲明語句聲明一個x變量，那麼&x表達式（取x變量的內存地址）將產生一個指向該整數變量的指針，指針對應的數據類型是`*int`，指針被稱之爲“指向int類型的指針”。如果指針名字爲p，那麼可以說“p指針指向變量x”，或者說“p指針保存了x變量的內存地址”。同時`*p`表達式對應p指針指向的變量的值。一般`*p`表達式讀取指針指向的變量的值，這裏爲int類型的值，同時因爲`*p`對應一個變量，所以該表達式也可以出現在賦值語句的左邊，表示更新指針所指向的變量的值。

```Go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

對於聚合類型每個成員——比如結構體的每個字段、或者是數組的每個元素——也都是對應一個變量，因此可以被取地址。

變量有時候被稱爲可尋址的值。即使變量由表達式臨時生成，那麼表達式也必須能接受`&`取地址操作。

任何類型的指針的零值都是nil。如果p指向某個有效變量，那麼`p != nil`測試爲真。指針之間也是可以進行相等測試的，只有當它們指向同一個變量或全部是nil時才相等。

```Go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```

在Go語言中，返回函數中局部變量的地址也是安全的。例如下面的代碼，調用f函數時創建局部變量v，在局部變量地址被返回之後依然有效，因爲指針p依然引用這個變量。

```Go
var p = f()

func f() *int {
	v := 1
	return &v
}
```

每次調用f函數都將返回不同的結果：

```Go
fmt.Println(f() == f()) // "false"
```

因爲指針包含了一個變量的地址，因此如果將指針作爲參數調用函數，那將可以在函數中通過該指針來更新變量的值。例如下面這個例子就是通過指針來更新變量的值，然後返回更新後的值，可用在一個表達式中（譯註：這是對C語言中`++v`操作的模擬，這裏只是爲了說明指針的用法，incr函數模擬的做法並不推薦）：

```Go
func incr(p *int) int {
	*p++ // 非常重要：只是增加p指向的變量的值，並不改變p指針！！！
	return *p
}

v := 1
incr(&v)              // side effect: v is now 2
fmt.Println(incr(&v)) // "3" (and v is 3)
```

每次我們對一個變量取地址，或者複製指針，我們都是爲原變量創建了新的別名。例如，`*p`就是變量v的別名。指針特別有價值的地方在於我們可以不用名字而訪問一個變量，但是這是一把雙刃劍：要找到一個變量的所有訪問者並不容易，我們必須知道變量全部的別名（譯註：這是Go語言的垃圾回收器所做的工作）。不僅僅是指針會創建別名，很多其他引用類型也會創建別名，例如slice、map和chan，甚至結構體、數組和接口都會創建所引用變量的別名。

指針是實現標準庫中flag包的關鍵技術，它使用命令行參數來設置對應變量的值，而這些對應命令行標誌參數的變量可能會零散分佈在整個程序中。爲了說明這一點，在早些的echo版本中，就包含了兩個可選的命令行參數：`-n`用於忽略行尾的換行符，`-s sep`用於指定分隔字符（默認是空格）。下面這是第四個版本，對應包路徑爲gopl.io/ch2/echo4。

<u><i>gopl.io/ch2/echo4</i></u>
```Go
// Echo4 prints its command-line arguments.
package main

import (
	"flag"
	"fmt"
	"strings"
)

var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

func main() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}
```

調用flag.Bool函數會創建一個新的對應布爾型標誌參數的變量。它有三個屬性：第一個是命令行標誌參數的名字“n”，然後是該標誌參數的默認值（這裏是false），最後是該標誌參數對應的描述信息。如果用戶在命令行輸入了一個無效的標誌參數，或者輸入`-h`或`-help`參數，那麼將打印所有標誌參數的名字、默認值和描述信息。類似的，調用flag.String函數將創建一個對應字符串類型的標誌參數變量，同樣包含命令行標誌參數對應的參數名、默認值、和描述信息。程序中的`sep`和`n`變量分別是指向對應命令行標誌參數變量的指針，因此必須用`*sep`和`*n`形式的指針語法間接引用它們。

當程序運行時，必須在使用標誌參數對應的變量之前先調用flag.Parse函數，用於更新每個標誌參數對應變量的值（之前是默認值）。對於非標誌參數的普通命令行參數可以通過調用flag.Args()函數來訪問，返回值對應一個字符串類型的slice。如果在flag.Parse函數解析命令行參數時遇到錯誤，默認將打印相關的提示信息，然後調用os.Exit(2)終止程序。

讓我們運行一些echo測試用例：

```
$ go build gopl.io/ch2/echo4
$ ./echo4 a bc def
a bc def
$ ./echo4 -s / a bc def
a/bc/def
$ ./echo4 -n a bc def
a bc def$
$ ./echo4 -help
Usage of ./echo4:
  -n    omit trailing newline
  -s string
        separator (default " ")
```

### 2.3.3. new函數

另一個創建變量的方法是調用內建的new函數。表達式new(T)將創建一個T類型的匿名變量，初始化爲T類型的零值，然後返回變量地址，返回的指針類型爲`*T`。

```Go
p := new(int)   // p, *int 類型, 指向匿名的 int 變量
fmt.Println(*p) // "0"
*p = 2          // 設置 int 匿名變量的值爲 2
fmt.Println(*p) // "2"
```

用new創建變量和普通變量聲明語句方式創建變量沒有什麼區別，除了不需要聲明一個臨時變量的名字外，我們還可以在表達式中使用new(T)。換言之，new函數類似是一種語法糖，而不是一個新的基礎概念。

下面的兩個newInt函數有着相同的行爲：

```Go
func newInt() *int {
	return new(int)
}

func newInt() *int {
	var dummy int
	return &dummy
}
```

每次調用new函數都是返回一個新的變量的地址，因此下面兩個地址是不同的：

```Go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

當然也可能有特殊情況：如果兩個類型都是空的，也就是說類型的大小是0，例如`struct{}`和`[0]int`，有可能有相同的地址（依賴具體的語言實現）（譯註：請謹慎使用大小爲0的類型，因爲如果類型的大小爲0的話，可能導致Go語言的自動垃圾回收器有不同的行爲，具體請查看`runtime.SetFinalizer`函數相關文檔）。

new函數使用通常相對比較少，因爲對於結構體來說，直接用字面量語法創建新變量的方法會更靈活（§4.4.1）。

由於new只是一個預定義的函數，它並不是一個關鍵字，因此我們可以將new名字重新定義爲別的類型。例如下面的例子：

```Go
func delta(old, new int) int { return new - old }
```

由於new被定義爲int類型的變量名，因此在delta函數內部是無法使用內置的new函數的。

### 2.3.4. 變量的生命週期

變量的生命週期指的是在程序運行期間變量有效存在的時間段。對於在包一級聲明的變量來說，它們的生命週期和整個程序的運行週期是一致的。而相比之下，局部變量的生命週期則是動態的：每次從創建一個新變量的聲明語句開始，直到該變量不再被引用爲止，然後變量的存儲空間可能被回收。函數的參數變量和返回值變量都是局部變量。它們在函數每次被調用的時候創建。

例如，下面是從1.4節的Lissajous程序摘錄的代碼片段：

```Go
for t := 0.0; t < cycles*2*math.Pi; t += res {
	x := math.Sin(t)
	y := math.Sin(t*freq + phase)
	img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
		blackIndex)
}
```

譯註：函數的右小括弧也可以另起一行縮進，同時爲了防止編譯器在行尾自動插入分號而導致的編譯錯誤，可以在末尾的參數變量後面顯式插入逗號。像下面這樣：

```Go
for t := 0.0; t < cycles*2*math.Pi; t += res {
	x := math.Sin(t)
	y := math.Sin(t*freq + phase)
	img.SetColorIndex(
		size+int(x*size+0.5), size+int(y*size+0.5),
		blackIndex, // 最後插入的逗號不會導致編譯錯誤，這是Go編譯器的一個特性
	)               // 小括弧另起一行縮進，和大括弧的風格保存一致
}
```

在每次循環的開始會創建臨時變量t，然後在每次循環迭代中創建臨時變量x和y。

那麼Go語言的自動垃圾收集器是如何知道一個變量是何時可以被回收的呢？這裏我們可以避開完整的技術細節，基本的實現思路是，從每個包級的變量和每個當前運行函數的每一個局部變量開始，通過指針或引用的訪問路徑遍歷，是否可以找到該變量。如果不存在這樣的訪問路徑，那麼說明該變量是不可達的，也就是說它是否存在並不會影響程序後續的計算結果。

因爲一個變量的有效週期只取決於是否可達，因此一個循環迭代內部的局部變量的生命週期可能超出其局部作用域。同時，局部變量可能在函數返回之後依然存在。

編譯器會自動選擇在棧上還是在堆上分配局部變量的存儲空間，但可能令人驚訝的是，這個選擇並不是由用var還是new聲明變量的方式決定的。

```Go
var global *int

func f() {
	var x int
	x = 1
	global = &x
}

func g() {
	y := new(int)
	*y = 1
}
```

f函數里的x變量必須在堆上分配，因爲它在函數退出後依然可以通過包一級的global變量找到，雖然它是在函數內部定義的；用Go語言的術語說，這個x局部變量從函數f中逃逸了。相反，當g函數返回時，變量`*y`將是不可達的，也就是說可以馬上被回收的。因此，`*y`並沒有從函數g中逃逸，編譯器可以選擇在棧上分配`*y`的存儲空間（譯註：也可以選擇在堆上分配，然後由Go語言的GC回收這個變量的內存空間），雖然這裏用的是new方式。其實在任何時候，你並不需爲了編寫正確的代碼而要考慮變量的逃逸行爲，要記住的是，逃逸的變量需要額外分配內存，同時對性能的優化可能會產生細微的影響。

Go語言的自動垃圾收集器對編寫正確的代碼是一個巨大的幫助，但也並不是說你完全不用考慮內存了。你雖然不需要顯式地分配和釋放內存，但是要編寫高效的程序你依然需要了解變量的生命週期。例如，如果將指向短生命週期對象的指針保存到具有長生命週期的對象中，特別是保存到全局變量時，會阻止對短生命週期對象的垃圾回收（從而可能影響程序的性能）。
